---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: apply-mapping
  labels:
    app.kubernetes.io/version: "1.7.3"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task to apply a mapping to a Snapshot. It will override the Snapshot file.
  params:
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the Snapshot spec in the config workspace to apply the mapping to
    - name: dataPath
      type: string
      description: Path to the JSON string of the merged data to use in the data workspace
    - name: failOnEmptyResult
      type: string
      description: Fail the task if the resulting snapshot contains 0 components
      default: "false"
  workspaces:
    - name: config
      description: The workspace where the extra config file containing the mapping and snapshot json reside
  results:
    - name: mapped
      type: string
      description: A true/false value depicting whether or not the snapshot was mapped.
  steps:
    - name: apply-mapping
      image: quay.io/konflux-ci/release-service-utils:d320c36f3d707cd5bfe55fe783f70236c06cc2e5
      script: |
        #!/usr/bin/env bash
        set -eux

        SNAPSHOT_SPEC_FILE="$(workspaces.config.path)/$(params.snapshotPath)"
        DATA_FILE="$(workspaces.config.path)/$(params.dataPath)"
        SNAPSHOT_SPEC_FILE_ORIG="${SNAPSHOT_SPEC_FILE}.orig"

        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was found."
            exit 1
        fi

        # Copy the original Snapshot spec file before overriding
        cp "${SNAPSHOT_SPEC_FILE}" "${SNAPSHOT_SPEC_FILE_ORIG}"

        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON file was found."
            printf "false" | tee "$(results.mapped.path)"
            exit 0
        fi

        MAPPING=$(jq '.mapping' "${DATA_FILE}")

        if [[ $MAPPING == "null" ]] ; then
            echo "Data file contains no mapping key."
            printf "false" | tee "$(results.mapped.path)"
            exit 0
        fi

        # Expected arguments are: [variable, substitute_map, labels_map]
        substitute() {
            variable=$1
            substitute_map=$2
            labels_map=$3

            result=""
            if [[ "$variable" == labels.* ]]; then
                label="${variable#labels.}"
                result="$(jq -r --arg labelval "$label" '.[$labelval] // ""' <<< "${labels_map}")"
            else
                result="$(jq -r --arg variable "$variable" '.[$variable] // ""' <<< "${substitute_map}")"
            fi
            echo "$result"
        }

        # Expected arguments are [tags, substitute_map, labels_map]
        # The tags argument is a json array
        translate_tags () {
            tags=$1
            substitute_map=$2
            labels_map=$3
            if [ "$tags" = '' ] ; then
                echo ''
                return
            fi

            translated_tags='[]'
            NUM_TAGS="$(jq 'length' <<< "${tags}")"
            for ((i = 0; i < NUM_TAGS; i++)); do
                tag="$(jq -r --argjson i "$i" '.[$i]' <<< "${tags}")"

                # Repeatedly translate {{}} references until none are left
                while [[ $tag =~ \{\{\ *([[:alnum:]_\.-]+)\ *\}\} ]]; do
                  # Extract the variable name (e.g., timestamp), trimming any surrounding spaces
                  var_name="${BASH_REMATCH[1]}"

                  # Sanity check of the template variable name
                  if [[ ! "$var_name" =~ ^[a-zA-Z0-9._-]+$ ]]; then
                    echo "Error: Invalid variable name in tag definition: $var_name" >&2
                    exit 1
                  fi

                  replacement=$(substitute "$var_name" "$substitute_map" "$labels_map")
                  if [ -z "$replacement" ]; then
                      echo Error: Substitution variable unknown or empty: "$var_name" >&2
                      exit 1
                  fi

                  # Shellcheck suggests ${var//find/replace}, but
                  # that won't work here - we need to match arbitrary amount of spaces
                  # shellcheck disable=SC2001
                  tag="$(sed "s/{{ *$var_name *}}/$replacement/" <<< "$tag")"
                done

                # Sanity check of the resulting tag value
                if [[ ! "$tag" =~ ^[a-zA-Z0-9._-]+$ ]]; then
                  echo "Error: Invalid tag format: $tag" >&2
                  exit 1
                fi

                # Avoid duplicate tags - only add a tag if not already present
                if [ "$(jq -c --arg tag "$tag" 'index($tag)' <<< "$translated_tags")" = null ]
                then
                  translated_tags="$(jq -c --arg tag "$tag" '. + [$tag]' <<< "$translated_tags")"
                fi
            done

            echo "$translated_tags"
        }

        convert_to_quay () { # Convert the registry.redhat.io URL to the quay.io format
            local repository=$1
            case "$repository" in
                registry.redhat.io/*)
                    echo "${repository/registry.redhat.io/quay.io/redhat-prod}" \
                        | sed 's|/|----|g; s|quay.io----redhat-prod----|quay.io/redhat-prod/|'
                    ;;
                registry.stage.redhat.io/*)
                    echo "${repository/registry.stage.redhat.io/quay.io/redhat-pending}" \
                        | sed 's|/|----|g; s|quay.io----redhat-pending----|quay.io/redhat-pending/|'
                    ;;
                *)
                    echo "$repository"
                    ;;
            esac
        }

        # This block is temporary to support both quay.io and registry.redhat.io
        # It should be removed once all repositories are migrated to registry.redhat.io
        convert_to_registry () { # Convert the repository URL to the registry.redhat.io format
            local repository=$1
            case "$repository" in
                quay.io/redhat-prod/*)
                    repository="${repository//quay.io\/redhat-prod/registry.redhat.io}"
                    repository="${repository//----//}"
                    echo "$repository"
                    ;;
                quay.io/redhat-pending/*)
                    repository="${repository//quay.io\/redhat-pending/registry.stage.redhat.io}"
                    repository="${repository//----//}"
                    echo "$repository"
                    ;;
                registry.redhat.io/* | registry.stage.redhat.io/*)
                    # Return the original Red Hat registry paths
                    echo "$repository"
                    ;;
                *)
                    # Return empty for unhandled formats
                    echo ""
                    ;;
            esac
        }

        convert_to_registry_access () { # Convert the repository URL to the registry.access.redhat.com format
            local repository=$1
            case "$repository" in
                registry.redhat.io/*)
                    echo "${repository/registry.redhat.io/registry.access.redhat.com}"
                    ;;
                registry.stage.redhat.io/*)
                    echo "${repository/registry.stage.redhat.io/registry.access.stage.redhat.com}"
                    ;;
                *)
                    echo ""
                    ;;
            esac
        }

        # Merge the mapping key contents in the data JSON file with the components key in the snapshot based
        # on component name. Save the output as a compact JSON in the mapped_snapshot.json file in the workspace
        { echo -n "$(cat "${SNAPSHOT_SPEC_FILE_ORIG}")"; echo "${MAPPING}"; } | jq -c -s '
          .[0] as $snapshot | .[0].components + .[1].components | group_by(.name) |
          [.[] | select(length > 1)] | map(reduce .[] as $x ({}; . * $x)) as $mergedComponents |
          $snapshot | .components = $mergedComponents' > "${SNAPSHOT_SPEC_FILE}"

        printf "true" | tee "$(results.mapped.path)"

        if [ "$(params.failOnEmptyResult)" = "true" ] && \
          [ "$(jq '.components | length' < "${SNAPSHOT_SPEC_FILE}")" -eq 0 ]; then
          echo "ERROR: Resulting snapshot contains 0 components. This means that there were 0 components present in"
          echo "both your Snapshot and your ReleasePlanAdmission mapping. Take a look at your component names and"
          echo "make sure that all components you want to release from the snapshot are present in the"
          echo "ReleasePlanAdmission (by the name field of the component)."
          echo "Components in snapshot: $(jq -c '[.components[].name]' "${SNAPSHOT_SPEC_FILE_ORIG}")"
          echo "Components in mapping: $(jq -c '[.components[].name]' <<< "${MAPPING}")"
          exit 1
        fi

        # Expand the tags in the data file
        defaultTags=$(jq '.defaults.tags // []' <<< "$MAPPING")
        defaultTimestampFormat=$(jq -r '.defaults.timestampFormat // "%s"' <<< "$MAPPING")
        currentTimestamp="$(date "+%Y%m%d %T")"
        NUM_MAPPED_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")
        for ((i = 0; i < NUM_MAPPED_COMPONENTS; i++)) ; do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_SPEC_FILE}")

            # images are required to use sha reference - check this
            NAME=$(jq -r '.name' <<< "$component")
            IMAGE_REF=$(jq -r '.containerImage' <<< "$component")
            if ! [[ "$IMAGE_REF" =~ ^[^:]+@sha256:[0-9a-f]+$ ]] ; then
              echo "Component ${NAME} contains an invalid containerImage value. sha reference is required: ${IMAGE_REF}"
              exit 1
            fi

            imageTags=$(jq '.tags // []' <<< "$component")
            git_sha=$(jq -r '.source.git.revision' <<< "$component") # this sets the value to "null" if it doesn't exist
            build_sha=$(echo "$IMAGE_REF" | cut -d ':' -f 2)
            passedTimestampFormat=$(jq -r --arg default "$defaultTimestampFormat" \
              '.timestampFormat // $default' <<< "$component")
            release_timestamp="$(date -d "$currentTimestamp" "+$passedTimestampFormat")"
            arch_json="$(get-image-architectures "${IMAGE_REF}")"
            # The build-date label and Created values are not the same per architecture, but we don't support separate
            # tags per arch. So, we just use the first digest listed.
            arch="$(jq -rs 'map(.platform.architecture) | .[0]' <<< "$arch_json")"
            os="$(jq -rs 'map(.platform.os) | .[0]' <<< "$arch_json")"
            image_metadata="$(skopeo inspect --no-tags --override-os "${os}" --override-arch "${arch}" \
              docker://"${IMAGE_REF}" | jq -c)"
            # For timestamp, use Labels.build-date and fallback to Created
            build_date="$(jq -r '.Labels."build-date" // .Created // ""' <<< "$image_metadata")"
            if [ "${build_date}" = "" ] ; then
              timestamp=""
            else
              timestamp="$(date -d "${build_date}" "+$passedTimestampFormat")"
            fi

            allTagsPreSubstitution=$(jq -n --argjson defaults "$defaultTags" --argjson imageTags \
              "$imageTags" '$defaults? + $imageTags? | unique')
            substitute_map="$(jq -n -c \
              --arg timestamp "${timestamp}" \
              --arg release_timestamp "${release_timestamp}" \
              --arg git_sha "${git_sha}" \
              --arg git_short_sha "${git_sha:0:7}" \
              --arg digest_sha "${build_sha}" \
              '$ARGS.named')"
            labels="$(jq -c '.Labels' <<< "${image_metadata}")"

            tags=$(translate_tags "${allTagsPreSubstitution}" "${substitute_map}" "${labels}")
            if [ "$(jq 'length' <<< "$tags")" -gt 0 ] ; then
              jq --argjson i "$i" --argjson updatedTags "$tags" '.components[$i].tags = $updatedTags' \
                "${SNAPSHOT_SPEC_FILE}" > /tmp/temp && mv /tmp/temp "${SNAPSHOT_SPEC_FILE}"
            fi

            # Also substitute filename values in the staged section of components
            STAGED_FILES=$(jq '.staged.files | length' <<< "$component")
            for ((j = 0; j < STAGED_FILES; j++)) ; do
                file=$(jq -c --argjson j "$j" '.staged.files[$j]' <<< "$component")
                filenameArrayPreSubstitution=$(jq '.filename' <<< "$file" | jq -cs)
                subbedFilename=$(translate_tags "${filenameArrayPreSubstitution}" \
                  "${substitute_map}" "${labels}" | jq -r '.[0]')
                jq --argjson i "$i" --argjson j "$j" --arg filename "$subbedFilename" \
                  '.components[$i].staged.files[$j].filename = $filename' "${SNAPSHOT_SPEC_FILE}" > /tmp/temp \
                  && mv /tmp/temp "${SNAPSHOT_SPEC_FILE}"
            done

            # Determine the format of the original repository and update keys accordingly
            repository=$(jq -r '.repository' <<< "$component")
            echo "Processing component: $NAME"
            echo "Original repository: $repository"

            # This block is temporary to support both quay.io and registry.redhat.io
            # It should be removed once all repositories are migrated to registry.redhat.io
            if [[ "$repository" == quay.io/redhat-prod/* || "$repository" == quay.io/redhat-pending/* ]]; then
                repository=$(convert_to_registry "$repository")
            fi

            # Convert to registry and quay format
            if [[ "$repository" == registry.redhat.io/* || "$repository" == registry.stage.redhat.io/* ]]; then
              rh_registry_repo=$repository
              registry_access_repo=$(convert_to_registry_access "$repository")
              repository=$(convert_to_quay "$repository")

              jq --argjson i "$i" \
                --arg repository "$repository" \
                --arg rh_registry_repo "$rh_registry_repo" \
                --arg registry_access_repo "$registry_access_repo" \
                '(.components[$i].repository = $repository) |
                    .components[$i]["rh-registry-repo"] = $rh_registry_repo |
                    .components[$i]["registry-access-repo"] = $registry_access_repo' \
              "${SNAPSHOT_SPEC_FILE}" > /tmp/temp && mv /tmp/temp "${SNAPSHOT_SPEC_FILE}"
            fi
        done
