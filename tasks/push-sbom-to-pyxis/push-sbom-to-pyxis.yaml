---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: push-sbom-to-pyxis
  labels:
    app.kubernetes.io/version: "0.6.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task that extracts sboms from pull specs and pushes them to Pyxis.
  params:
    - name: pyxisSecret
      type: string
      description: |
        The kubernetes secret to use to authenticate to Pyxis. It needs to contain two keys: key and cert
    - name: server
      type: string
      description: The server type to use. Options are 'production' and 'stage'
      default: production
    - name: concurrentLimit
      type: string
      description: The maximum number of images to be processed at once
      default: 4
  workspaces:
    - name: data
      description: The workspace where the snapshot spec json file resides
  volumes:
    - name: workdir
      emptyDir: {}
  steps:
    - name: download-sbom-files
      image:
        quay.io/redhat-appstudio/release-service-utils:4d00a5731e96e341e0104ad2374792b985330c87
      volumeMounts:
        - mountPath: /workdir
          name: workdir
      script: |
        #!/usr/bin/env sh
        set -eux

        PYXIS_JSON_PATH=$(workspaces.data.path)/pyxis.json

        mkdir /workdir/sboms
        cd /workdir/sboms

        IMAGEURL_LENGTH=($(jq -r '.components | length' $PYXIS_JSON_PATH))
        for(( i=0; i<${IMAGEURL_LENGTH}; i++ )); do
          IMAGEURL=$(jq -r ".components[$i].containerImage" $PYXIS_JSON_PATH)
          PYXIS_IMAGES=$(jq ".components[$i].pyxisImages" $PYXIS_JSON_PATH)
          PYXIS_IMAGES_LENGTH=$(jq 'length' <<< "${PYXIS_IMAGES}")
          for(( a=0; a<${PYXIS_IMAGES_LENGTH}; a++ )); do
            ARCH=$(jq -r ".[$a].arch" <<< "${PYXIS_IMAGES}")
            IMAGEID=$(jq -r ".[$a].imageId" <<< "${PYXIS_IMAGES}")
            echo "Fetching sbom for ${ARCH} architecture image: ${IMAGEURL}"
            cosign download sbom --output-file "${IMAGEID}.json" "${IMAGEURL}"
          done
        done

        SBOM_COUNT=$(ls *.json | wc -l )
        IMAGEIDS_COUNT=$(jq "[.components[].pyxisImages[].imageId] | length" $PYXIS_JSON_PATH)
        if [ $SBOM_COUNT != $IMAGEIDS_COUNT ]; then
          echo "ERROR: Expected to fetch sbom for ${IMAGEIDS_COUNT} images, but only $SBOM_COUNT were saved"
          exit 1
        fi

    - name: push-sbom-files-to-pyxis
      image:
        quay.io/redhat-appstudio/release-service-utils:4d00a5731e96e341e0104ad2374792b985330c87
      env:
        - name: pyxisCert
          valueFrom:
            secretKeyRef:
              name: $(params.pyxisSecret)
              key: cert
        - name: pyxisKey
          valueFrom:
            secretKeyRef:
              name: $(params.pyxisSecret)
              key: key
      volumeMounts:
        - mountPath: /workdir
          name: workdir
      script: |
        #!/usr/bin/env sh
        set -eu

        if [[ "$(params.server)" == "production" ]]
        then
          export PYXIS_GRAPHQL_API="https://graphql-pyxis.api.redhat.com/graphql/"
        elif [[ "$(params.server)" == "stage" ]]
        then
          export PYXIS_GRAPHQL_API="https://graphql-pyxis.preprod.api.redhat.com/graphql/"
        else
          echo "Invalid server parameter. Only 'production' and 'stage' are allowed."
          exit 1
        fi

        export PYXIS_CERT_PATH=/workdir/crt
        export PYXIS_KEY_PATH=/workdir/key
        echo "${pyxisCert}" > $PYXIS_CERT_PATH
        echo "${pyxisKey}" > $PYXIS_KEY_PATH

        cd /workdir/sboms

        N=$(params.concurrentLimit)  # The maximum number of images to be processed at once
        declare -a jobs=()
        declare -a files=()
        total=$(ls *.json | wc -l )
        count=0
        success=true
        echo "Starting sbom upload for $total files in total. " \
          "Up to $N files will be uploaded at once..."

        for FILE in *.json; do
          echo Uploading sbom to Pyxis: $FILE
          upload_sbom --retry --sbom-path $FILE > ${FILE}.out 2>&1 &

          jobs+=($!)  # Save the background process ID
          files+=($FILE)
          ((++count))

          if [ $((count%N)) -eq 0 -o $((count)) -eq $total ]; then
            echo Waiting for the current batch of background processes to finish
            for i in "${!jobs[@]}"; do
              if ! wait ${jobs[i]}; then
                echo "Error: upload of ${files[i]} failed"
                success=false
              fi
            done

            echo
            echo Printing outputs for current upload_sbom script runs
            for FILE in ${files[@]}; do
              echo "=== $FILE ==="
              cat "${FILE}.out"
              echo
            done

            if [ $success != "true" ]; then
              echo ERROR: At least one upload in the last batch failed
              exit 1
            fi

            # Reset job and files arrays for the next batch
            jobs=()
            files=()
          fi
        done
