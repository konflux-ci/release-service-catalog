---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: create-pyxis-image
  labels:
    app.kubernetes.io/version: "3.3.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task that pushes metadata to Pyxis for all container images contained in a snapshot
  params:
    - name: server
      type: string
      description: The server type to use. Options are 'production','production-internal,'stage-internal' and 'stage'.
      default: production
    - name: pyxisSecret
      type: string
      description: |
        The kubernetes secret to use to authenticate to Pyxis. It needs to contain two keys: key and cert
    - name: certified
      type: string
      description: If set to true, the images will be marked as certified in their Pyxis entries
      default: "false"
    - name: isLatest
      type: string
      description: If set to true, the images will have a latest tag added with their Pyxis entries
      default: "false"
    - name: rhPush
      type: string
      description: >
        If set to true, an additional entry will be created in ContainerImage.repositories with
        the registry and repository fields converted to use Red Hat's official registry.
        E.g. a mapped repository of "quay.io/redhat-pending/product---my-image" will be converted
        to use registry "registry.access.redhat.com" and repository "product/my-image". Also, this
        repository entry will be marked as published.
      default: "false"
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the mapped Snapshot spec in the data workspace
  workspaces:
    - name: data
      description: The workspace where the snapshot spec and data json files reside
  results:
    - name: pyxisDataPath
      description: The relative path in the workspace to the stored pyxis data json
  steps:
    - name: create-pyxis-image
      image: quay.io/konflux-ci/release-service-utils:65d8db844c008e7736ec8dff307868525279484d
      env:
        - name: pyxisCert
          valueFrom:
            secretKeyRef:
              name: $(params.pyxisSecret)
              key: cert
        - name: pyxisKey
          valueFrom:
            secretKeyRef:
              name: $(params.pyxisSecret)
              key: key
      script: |
        #!/usr/bin/env bash
        set -exo pipefail

        if [[ "$(params.server)" == "production" ]]
        then
          PYXIS_URL="https://pyxis.api.redhat.com/"
          PYXIS_GRAPHQL_URL="https://graphql-pyxis.api.redhat.com/graphql/"
        elif [[ "$(params.server)" == "stage" ]]
        then
          PYXIS_URL="https://pyxis.preprod.api.redhat.com/"
          PYXIS_GRAPHQL_URL="https://graphql-pyxis.preprod.api.redhat.com/graphql/"
        elif [[ "$(params.server)" == "production-internal" ]]
        then
          PYXIS_URL="https://pyxis.engineering.redhat.com/"
          PYXIS_GRAPHQL_URL="https://graphql.pyxis.engineering.redhat.com/graphql/"
        elif [[ "$(params.server)" == "stage-internal" ]]
        then
          PYXIS_URL="https://pyxis.stage.engineering.redhat.com/"
          PYXIS_GRAPHQL_URL="https://graphql.pyxis.stage.engineering.redhat.com/graphql/"
        else
          echo "Invalid server parameter. Only 'production','production-internal,'stage-internal' and 'stage' allowed."
          exit 1
        fi

        SNAPSHOT_SPEC_FILE="$(workspaces.data.path)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        PYXIS_DATA_PATH="$(dirname $(params.snapshotPath))/pyxis.json"
        echo -n "${PYXIS_DATA_PATH}" > $(results.pyxisDataPath.path)

        set +x
        echo "${pyxisCert}" > /tmp/crt
        echo "${pyxisKey}" > /tmp/key
        set -x

        AUTH_FILE=$(mktemp)

        COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")
        JSON_OUTPUT='{}'
        for (( i=0; i < $COMPONENTS; i++ )); do
            CONTAINER_IMAGE=$(jq -r ".components[${i}].containerImage" "${SNAPSHOT_SPEC_FILE}")
            JSON_OUTPUT=$(jq --argjson id $i --arg image "${CONTAINER_IMAGE}" \
              '.components[$id] += { "containerImage": $image, "pyxisImages": []}' <<< "$JSON_OUTPUT")
            REPOSITORY=$(jq -r ".components[${i}].repository" "${SNAPSHOT_SPEC_FILE}")
            REPOSITORY=${REPOSITORY%:*} # strip tag just in case - it should not be there
            SOURCE_REPO=${CONTAINER_IMAGE%%@sha256:*}
            DIGEST="${CONTAINER_IMAGE##*@}"
            PULLSPEC="${REPOSITORY}@${DIGEST}"
            MEDIA_TYPE=$(skopeo inspect --raw "docker://${PULLSPEC}" | jq -r .mediaType)
            TAGS=$(jq -r ".components[${i}].tags | join(\" \")" "${SNAPSHOT_SPEC_FILE}")

            # oras has very limited support for selecting the right auth entry,
            # so create a custom auth file with just one entry before each oras call
            select-oci-auth "${SOURCE_REPO}" > "$AUTH_FILE"
            DOCKERFILE_DIR="$(mktemp -d)"
            DOCKERFILE_PATH=""
            # try fetching Dockerfile for the image
            if oras pull --registry-config "$AUTH_FILE" "${SOURCE_REPO}:${DIGEST}.dockerfile" -o "${DOCKERFILE_DIR}"
            then
              DOCKERFILE_PATH="${DOCKERFILE_DIR}/Dockerfile"
              if [ ! -f "${DOCKERFILE_PATH}" ]; then
                echo Error: Dockerfile pull succeeded, but the Dockerfile was not saved.
                exit 1
              fi
            else
              echo "Unable to get Dockerfile for the image. Maybe it's not enabled in the build pipeline?"
            fi

            select-oci-auth "${REPOSITORY}" > "$AUTH_FILE"

            index=0
            while IFS= read -r ARCH_DETAIL;
            do
                OS=$(jq -r '.platform.os' <<< "$ARCH_DETAIL")
                ARCH=$(jq -r '.platform.architecture' <<< "$ARCH_DETAIL")
                ARCH_DIGEST=$(jq -r '.digest' <<< "$ARCH_DETAIL")

                ORAS_ARGS=()
                if [[ "MEDIA_TYPE" == "application/vnd.docker.distribution.manifest.list.v2+json" ]]\
                  || [[ "MEDIA_TYPE" == "application/vnd.oci.image.index.v1+json" ]]; then
                  ORAS_ARGS+=("--platform $os/$arch")
                fi

                oras manifest fetch \
                  --registry-config "$AUTH_FILE" \
                  "${ORAS_ARGS[@]}" \
                  "${PULLSPEC}" \
                      | tee /tmp/oras-manifest-fetch.json

                PYXIS_CERT_PATH=/tmp/crt PYXIS_KEY_PATH=/tmp/key create_container_image \
                  --pyxis-url $PYXIS_URL \
                  --certified $(params.certified) \
                  --tags "$TAGS" \
                  --is-latest $(params.isLatest) \
                  --verbose \
                  --oras-manifest-fetch "/tmp/oras-manifest-fetch.json" \
                  --name "$REPOSITORY" \
                  --media-type "$MEDIA_TYPE" \
                  --digest "$DIGEST" \
                  --architecture-digest "$ARCH_DIGEST" \
                  --architecture "$ARCH" \
                  --rh-push "$(params.rhPush)" \
                  --dockerfile "${DOCKERFILE_PATH}" | tee "/tmp/output"
                # The rh-push-to-external-registry e2e test depends on this line being in the task log
                IMAGEID=$(awk '/The image id is/{print $NF}' /tmp/output)

                # Remove the new image tags from all previous images, but only if rhPush=true
                if [ "$(params.rhPush)" = "true" ]; then
                  PYXIS_CERT_PATH=/tmp/crt PYXIS_KEY_PATH=/tmp/key cleanup_tags \
                    --verbose \
                    --retry \
                    --pyxis-graphql-api $PYXIS_GRAPHQL_URL \
                    $IMAGEID
                fi

                JSON_OUTPUT=$(jq --argjson component_index $i --argjson arch_index $index \
                  --arg arch "${ARCH}" --arg imageId "${IMAGEID}" --arg digest "${DIGEST}" \
                  --arg arch_digest "${ARCH_DIGEST}" --arg os "${OS}" \
                    '.components[$component_index].pyxisImages[$arch_index] += {
                      "arch": $arch,
                      "imageId": $imageId,
                      "digest": $digest,
                      "arch_digest": $arch_digest,
                      "os": $os}' <<< "$JSON_OUTPUT")

                index=$((index + 1))
            done <<< $(get-image-architectures "${PULLSPEC}" | jq -c)
        done
        echo "$JSON_OUTPUT" | tee "$(workspaces.data.path)/${PYXIS_DATA_PATH}"
